"""
Strategy Arsenal System - Plugin Architecture for Trading Strategies

This system allows multiple strategies to be plugged in, managed, and switched dynamically.
Each strategy operates with its own risk rules and can be enabled/disabled independently.
"""

import logging
from typing import Dict, Any, List, Optional, Type
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime

logger = logging.getLogger(__name__)


class StrategyType(Enum):
    """Types of trading strategies."""
    TREND_FOLLOWING = "trend_following"
    MEAN_REVERSION = "mean_reversion"
    BREAKOUT = "breakout"
    SCALPING = "scalping"
    ARBITRAGE = "arbitrage"
    MARKET_MAKING = "market_making"
    HYBRID = "hybrid"


class TimeFrame(Enum):
    """Trading timeframes."""
    TICK = "tick"  # Millisecond resolution
    M1 = "1m"
    M5 = "5m"
    M15 = "15m"
    H1 = "1h"
    H4 = "4h"
    D1 = "1d"


class MarketType(Enum):
    """Market types."""
    CRYPTO = "crypto"
    FOREX = "forex"
    STOCKS = "stocks"
    FUTURES = "futures"
    OPTIONS = "options"


@dataclass
class StrategyMetadata:
    """Metadata for a trading strategy."""
    name: str
    description: str
    version: str
    author: str
    strategy_type: StrategyType
    timeframe: TimeFrame
    markets: List[MarketType]
    risk_level: int  # 1-5, where 5 is highest risk
    min_capital: float
    max_position_size: float
    default_stop_loss_percent: float
    default_take_profit_percent: float
    requires_data: List[str] = field(default_factory=list)
    tags: List[str] = field(default_factory=list)


@dataclass
class StrategyConfig:
    """Runtime configuration for a strategy."""
    enabled: bool = True
    position_size_percent: float = 1.0  # % of capital per trade
    max_concurrent_trades: int = 1
    stop_loss_percent: float = 2.0
    take_profit_percent: float = 5.0
    trailing_stop: bool = False
    trailing_stop_percent: float = 1.0
    custom_params: Dict[str, Any] = field(default_factory=dict)


@dataclass
class Signal:
    """Trading signal generated by a strategy."""
    strategy_name: str
    symbol: str
    side: str  # 'buy' or 'sell'
    strength: float  # 0.0 to 1.0
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    timeframe: Optional[str] = None
    reason: str = ""
    timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    metadata: Dict[str, Any] = field(default_factory=dict)


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    All strategies must implement:
    - generate_signals(): Analyze market and produce trading signals
    - on_tick(): Handle real-time price updates
    - on_trade_executed(): Respond to trade execution
    - on_trade_closed(): Respond to trade closure
    """
    
    def __init__(
        self,
        metadata: StrategyMetadata,
        config: Optional[StrategyConfig] = None
    ):
        """Initialize strategy with metadata and config."""
        self.metadata = metadata
        self.config = config or StrategyConfig()
        self.is_active = False
        self.positions: List[Dict[str, Any]] = []
        self.pending_signals: List[Signal] = []
        
        logger.info(f"âœ¨ Strategy initialized: {metadata.name} v{metadata.version}")
    
    @abstractmethod
    def generate_signals(
        self,
        market_data: Dict[str, Any],
        account: Dict[str, Any]
    ) -> List[Signal]:
        """
        Generate trading signals based on market data.
        
        Args:
            market_data: Current market state (prices, volume, indicators, etc.)
            account: Account information (balance, equity, positions, etc.)
            
        Returns:
            List of Signal objects
        """
        pass
    
    @abstractmethod
    def on_tick(self, tick: Dict[str, Any]) -> Optional[Signal]:
        """
        Handle real-time tick data (for ultra-fast strategies).
        
        Args:
            tick: Tick data (price, volume, timestamp)
            
        Returns:
            Signal if action needed, None otherwise
        """
        pass
    
    @abstractmethod
    def on_trade_executed(self, trade: Dict[str, Any]) -> None:
        """
        React to trade execution.
        
        Args:
            trade: Executed trade details
        """
        pass
    
    @abstractmethod
    def on_trade_closed(self, trade: Dict[str, Any], profit: float) -> None:
        """
        React to trade closure.
        
        Args:
            trade: Closed trade details
            profit: Profit/loss from trade
        """
        pass
    
    def activate(self) -> None:
        """Activate the strategy."""
        self.is_active = True
        logger.info(f"â–¶ï¸  Strategy activated: {self.metadata.name}")
    
    def deactivate(self) -> None:
        """Deactivate the strategy."""
        self.is_active = False
        logger.info(f"â¸ï¸  Strategy deactivated: {self.metadata.name}")
    
    def update_config(self, config: StrategyConfig) -> None:
        """Update strategy configuration."""
        self.config = config
        logger.info(f"âš™ï¸  Strategy config updated: {self.metadata.name}")
    
    def get_status(self) -> Dict[str, Any]:
        """Get current strategy status."""
        return {
            "name": self.metadata.name,
            "version": self.metadata.version,
            "is_active": self.is_active,
            "type": self.metadata.strategy_type.value,
            "timeframe": self.metadata.timeframe.value,
            "positions_count": len(self.positions),
            "pending_signals": len(self.pending_signals),
            "config": {
                "enabled": self.config.enabled,
                "position_size": self.config.position_size_percent,
                "stop_loss": self.config.stop_loss_percent,
                "take_profit": self.config.take_profit_percent
            }
        }


class StrategyArsenal:
    """
    Manages multiple trading strategies.
    
    Responsibilities:
    - Register and manage strategies
    - Route market data to active strategies
    - Collect and prioritize signals
    - Track strategy performance
    - Enable/disable strategies dynamically
    """
    
    def __init__(self):
        """Initialize the strategy arsenal."""
        self.strategies: Dict[str, BaseStrategy] = {}
        self.active_strategies: List[str] = []
        self.strategy_performance: Dict[str, Dict[str, Any]] = {}
        
        logger.info("ğŸ¯ StrategyArsenal initialized")
    
    def register_strategy(
        self,
        strategy: BaseStrategy,
        auto_activate: bool = False
    ) -> None:
        """
        Register a new strategy.
        
        Args:
            strategy: Strategy instance
            auto_activate: Whether to activate immediately
        """
        name = strategy.metadata.name
        
        if name in self.strategies:
            logger.warning(f"Strategy '{name}' already registered, overwriting")
        
        self.strategies[name] = strategy
        
        # Initialize performance tracking
        self.strategy_performance[name] = {
            "total_signals": 0,
            "signals_executed": 0,
            "total_trades": 0,
            "winning_trades": 0,
            "total_profit": 0.0,
            "win_rate": 0.0,
            "avg_profit": 0.0
        }
        
        if auto_activate:
            strategy.activate()
            self.active_strategies.append(name)
        
        logger.info(f"âœ… Strategy registered: {name} (active={auto_activate})")
    
    def activate_strategy(self, strategy_name: str) -> bool:
        """Activate a strategy by name."""
        if strategy_name not in self.strategies:
            logger.error(f"Strategy '{strategy_name}' not found")
            return False
        
        strategy = self.strategies[strategy_name]
        strategy.activate()
        
        if strategy_name not in self.active_strategies:
            self.active_strategies.append(strategy_name)
        
        return True
    
    def deactivate_strategy(self, strategy_name: str) -> bool:
        """Deactivate a strategy by name."""
        if strategy_name not in self.strategies:
            logger.error(f"Strategy '{strategy_name}' not found")
            return False
        
        strategy = self.strategies[strategy_name]
        strategy.deactivate()
        
        if strategy_name in self.active_strategies:
            self.active_strategies.remove(strategy_name)
        
        return True
    
    def get_all_signals(
        self,
        market_data: Dict[str, Any],
        account: Dict[str, Any]
    ) -> List[Signal]:
        """
        Collect signals from all active strategies.
        
        Args:
            market_data: Current market data
            account: Account information
            
        Returns:
            List of signals from all active strategies
        """
        all_signals = []
        
        for strategy_name in self.active_strategies:
            strategy = self.strategies[strategy_name]
            
            if not strategy.config.enabled:
                continue
            
            try:
                signals = strategy.generate_signals(market_data, account)
                
                # Track performance
                self.strategy_performance[strategy_name]["total_signals"] += len(signals)
                
                all_signals.extend(signals)
                
            except Exception as e:
                logger.error(f"Error generating signals from '{strategy_name}': {e}")
        
        # Sort by signal strength (highest first)
        all_signals.sort(key=lambda s: s.strength, reverse=True)
        
        return all_signals
    
    def route_tick(self, tick: Dict[str, Any]) -> List[Signal]:
        """
        Route tick data to active strategies that support tick trading.
        
        Args:
            tick: Tick data
            
        Returns:
            List of signals generated from tick
        """
        signals = []
        
        for strategy_name in self.active_strategies:
            strategy = self.strategies[strategy_name]
            
            if not strategy.config.enabled:
                continue
            
            # Only route to tick-based strategies
            if strategy.metadata.timeframe != TimeFrame.TICK:
                continue
            
            try:
                signal = strategy.on_tick(tick)
                if signal:
                    signals.append(signal)
            except Exception as e:
                logger.error(f"Error in tick handler for '{strategy_name}': {e}")
        
        return signals
    
    def notify_trade_executed(self, trade: Dict[str, Any]) -> None:
        """Notify all strategies of trade execution."""
        strategy_name = trade.get("strategy_name")
        
        if strategy_name and strategy_name in self.strategies:
            strategy = self.strategies[strategy_name]
            strategy.on_trade_executed(trade)
            
            # Update performance
            self.strategy_performance[strategy_name]["signals_executed"] += 1
            self.strategy_performance[strategy_name]["total_trades"] += 1
    
    def notify_trade_closed(
        self,
        trade: Dict[str, Any],
        profit: float
    ) -> None:
        """Notify strategies of trade closure and update performance."""
        strategy_name = trade.get("strategy_name")
        
        if strategy_name and strategy_name in self.strategies:
            strategy = self.strategies[strategy_name]
            strategy.on_trade_closed(trade, profit)
            
            # Update performance metrics
            perf = self.strategy_performance[strategy_name]
            perf["total_profit"] += profit
            
            if profit > 0:
                perf["winning_trades"] += 1
            
            # Recalculate metrics
            if perf["total_trades"] > 0:
                perf["win_rate"] = (perf["winning_trades"] / perf["total_trades"]) * 100
                perf["avg_profit"] = perf["total_profit"] / perf["total_trades"]
    
    def get_strategy_list(self) -> List[Dict[str, Any]]:
        """Get list of all registered strategies."""
        return [
            {
                "name": name,
                "type": strategy.metadata.strategy_type.value,
                "version": strategy.metadata.version,
                "description": strategy.metadata.description,
                "is_active": strategy.is_active,
                "timeframe": strategy.metadata.timeframe.value,
                "risk_level": strategy.metadata.risk_level,
                "performance": self.strategy_performance.get(name, {})
            }
            for name, strategy in self.strategies.items()
        ]
    
    def get_strategy_status(self, strategy_name: str) -> Optional[Dict[str, Any]]:
        """Get detailed status of a specific strategy."""
        if strategy_name not in self.strategies:
            return None
        
        strategy = self.strategies[strategy_name]
        status = strategy.get_status()
        status["performance"] = self.strategy_performance.get(strategy_name, {})
        
        return status
